<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0070)http://www.cslab.ntua.gr/courses/os/files/2017-18/os-notes-fileio.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="generator" content="HTML Tidy for Linux (vers 7 December 2008), see www.w3.org">
  
  <meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/">

  <title>Ε/Ε Αρχείων στο Unix</title>
  <style type="text/css">
/*<![CDATA[*/

  body {
        font-family: 'Lucida Grande', Verdana, Arial, Sans-Serif;
        background-color: #ffffff; 
        color: black;
  }

  p {
        text-align: justify;
        margin-left: 10px;
        margin-right: 10px;
        padding-left: 10px;
        padding-right: 10px;
  }

  h1 {
        text-align: center;
        text-decoration: underline;
  }

  h2 {
        text-align: center;
        font-size: 17px;
  }

  .section h1 {
        font-size: 16px;
        margin-right: 10px;
        padding-left: 10px;
        padding-right: 10px;
        text-align: left;
  }

  pre.literal-block {
        margin: 5px;
        margin-right: 100px;
        margin-left: 50px;
        padding: 5px;
        border: 1px dashed black; 
        background-color:  #efefef;
  }

  a:link, a:visited {
        color: #105ebd;
        text-decoration: none;
        border-bottom: 1px dashed  #105ebd;
  }

  a:hover, a:active {
        color:#4a5d74;
  }

  ul {
  }

  li {
        padding-top: 10px;
        margin-left: 10px;
        margin-right: 10px;
        text-align: justify;
  }


  blockquote li {
        padding-top: 1px;
  }

  img {
        padding: 5px;
        margin-bottom: 5px;
  }

  /*]]>*/
  </style>
</head>

<body>
  <div class="document" id="unix">
    <h1 class="title">Ε/Ε Αρχείων στο Unix</h1>

    <h2 class="subtitle" id="id1">Μια σύντομη εισαγωγή</h2>

    <p>Οι βασικές κλήσεις συστήματος για Ε/Ε με αρχεία στο Unix
    είναι οι open(), read(), write(), close().</p>

    <div class="section" id="id2">
      <h1>Άνοιγμα αρχείου</h1>

      <p>Αρχικά η διεργασία <em>ανοίγει</em> το αρχείο,
      χρησιμοποιώντας την κλήση συστήματος open(). Η open()
      επιστρέφει είτε -1 σε περίπτωση αποτυχίας, είτε έναν μη
      αρνητικό ακέραιο. Ο ακέραιος αυτός ονομάζεται περιγραφητής
      αρχείου, και από εδώ και στο εξής χρησιμοποιείται σε κάθε
      άλλη κλήση συστήματος για να αναφέρεται στο ανοιχτό αρχείο.
      Παράδειγμα:</p>
      <pre class="literal-block">int fd;

fd = open("/home/user/myfile", O_RDONLY);
if (fd &lt; 0) {
      perror("open");
      exit(1);
}
</pre>

      <p>Ο κώδικας ανοίγει το αρχείο μόνο για ανάγνωση (O_RDONLY
      flag) και κράταει τον περιγραφητή στη μεταβλητή fd. Αν
      αποτύχει (π.χ. δεν υπάρχει το συγκεκριμένο αρχείο) τυπώνει
      κατάλληλο διαγνωστικό και τερματίζει.</p>
    </div>

    <div class="section" id="id3">
      <h1>Ανάγνωση από αρχείο</h1>

      <p>Κάθε περιγραφητής σχετίζεται με συγκεκριμένη <em>θέση</em>
      μέσα στο ανοιχτό αρχείο, απ'όπου γίνονται όλες οι
      αναγνώσεις/εγγραφές. Κάθε ανάγνωση/εγγραφή προχωράει τη θέση
      ανάγνωσης/εγγραφής μέσα στο ανοιχτό αρχείο. Η κλήση read()
      διαβάζει έναν αριθμό από bytes, όσα ζητήσουμε, από την
      τρέχουσα θέση ανάγνωσης/εγγραφής και τα αποθηκεύει στη
      μνήμη.</p>

      <p>Από το manual page φαίνεται τι χρειάζεται να γίνει
      #include και πώς καλείται:</p>
      <pre class="literal-block">#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t count);
</pre>

      <p>Οπότε, με μια κλήση όπως αυτή:</p>
      <pre class="literal-block">char buf[1000];
ssize_t ret;

ret = read(fd, buf, 1000);
</pre>

      <p>Ζητάμε να διαβαστούν 1000 bytes και να αποθηκευτούν όπου
      δείχνει ο δείκτης buf, δηλαδή στον πίνακα buf[] ξεκινώντας
      από το buf[0]. Φροντίζουμε να υπάρχει αρκετός χώρος για τα
      δεδομένα, αλλιώς το πρόγραμμα εκτελεί μη επιτρεπόμενη
      πρόσβαση στη μνήμη και 99.99% θα τερματίσει με "Segmentation
      Fault".</p>

      <p>Η read() επιστρέφει ένα από τα παρακάτω:</p>

      <blockquote>
        <ul class="simple">
          <li>Αρνητική τιμή (-1): συνέβη σφάλμα Ε/Ε, ο τύπος του
          σφάλματος είναι στη μεταβλητή errno. Κάνουμε
          perror("read") και τερματίζουμε το πρόγραμμα.</li>

          <li>0: End-of-file: Η θέση ανάγνωσης/εγγραφής ήταν στο
          τέλος του αρχείου, δεν υπάρχουν άλλα δεδομένα.</li>

          <li>Οποιονδήποτε αριθμό από 1 έως count: Επιστρέφει πόσα
          bytes διάβασε πραγματικά. Είναι πολύ σημαντικό ότι η
          read() <em>δεν</em> διαβάζει υποχρεωτικά όσα της
          ζητήσαμε, για διάφορους λόγους. Έχει το δικαίωμα να
          διαβάσει όσα θέλει, από 1 έως count και να επιστρέψει τον
          αριθμό τους. Πχ, αν είμαστε 40 bytes πριν από το τέλος
          του αρχείου και ζητήσουμε 1000, μάλλον θα πάρουμε 40
          bytes στον buffer και στην επόμενη κλήση θα επιστραφεί 0
          (end of file).</li>
        </ul>
      </blockquote>

      <p>Οπότε:</p>
      <pre class="literal-block">if (ret &lt; 0) {
      perror("read");
      exit(1);
} else if (ret == 0) {
      printf("I am at end-of-file\n");
} else {
      printf("I read %d bytes\n", ret);
}
</pre>
    </div>

    <div class="section" id="id4">
      <h1>Εγγραφή σε αρχείο</h1>

      <p>Αντίστοιχα ισχύουν για την κλήση write():</p>
      <pre class="literal-block">#include &lt;unistd.h&gt;

ssize_t write(int fd, const void *buf, size_t count);
</pre>

      <p>Η write() γράφει στην τρέχουσα θέση ανάγνωσης εγγραφής το
      πολύ count bytes, τα οποία προέρχονται από την θέση μνήμης
      buf. Παράδειγμα:</p>
      <pre class="literal-block">char buf[] = "kalhmera";
write(fd, buf, strlen(buf));
</pre>

      <p>οπότε 8 bytes θα γραφτούν στο αρχείο. Η τιμή επιστροφής
      είναι:</p>

      <blockquote>
        <ul class="simple">
          <li>Αρνητική τιμη (-1): συνέβη σφάλμα E/E, ο τύπος του
          είναι στη μεταβλητή errno, κάνουμε perror("write") και
          τερματίζουμε το πρόγραμμα.</li>

          <li>0: δεν υπάρχει σφάλμα, αλλά για κάποιο λόγο δεν
          μπόρεσε να γράψει τα δεδομένα. Πρακτικά δεν συμβαίνει
          ποτέ.</li>

          <li>έναν αριθμό από 1 έως count που δείχνει πόσα bytes
          έγραψε.</li>
        </ul>
      </blockquote>

      <p>Οπότε:</p>
      <pre class="literal-block">if (ret &lt; 0) {
      perror("write");
      exit(1);
} else if (ret == 0) {
      printf("write returned zero?!\n");
} else {
      printf("I wrote %d bytes\n", ret);
}
</pre>
    </div>

    <div class="section" id="id5">
      <h1>Κλείσιμο αρχείου</h1>

      <p>Τέλος, κλείνουμε το ανοιχτό αρχείο με close στον
      περιγραφητή:</p>
      <pre class="literal-block">if (close(fd) &lt; 0) {
      perror("close");
      exit(1);
}
</pre>

      <p>Είναι πολύ σημαντικό μετά από κάθε κλήση συστήματος να
      γίνεται έλεγχος επιτυχίας. Αν κάτι πάει στραβά πρέπει να
      δίνεται έγκαιρα κάποιο μήνυμα λάθους και να μην συνεχίζει η
      εκτέλεση του προγράμματος, ώστε να μπορείτε να εντοπίζετε
      ευκολότερα προγραμματιστικά σας λάθη.</p>

      <p>Περισσότερες πληροφορίες για όλα τα παραπάνω μπορείτε να
      βρείτε στα Manual pages: man 2 open, close, read, write.</p>
    </div>
  </div>


</body></html>